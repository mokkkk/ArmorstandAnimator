using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using SFB;

namespace ArmorstandAnimator
{
    public class GenerateAnimationMcfunctionNew : MonoBehaviour
    {
        // モデル用ファンクション
        [SerializeField]
        private GenerateModelMcFunctionNew modelMcfunc;

        // モデル名
        private string modelName;
        // アニメーション名
        private string animationName;

        // 一般設定
        private GeneralSettingUI generalSetting;


        // 署名
        private const string FuncAuthor = "# This function was generated by ArmorstandAnimator";
        // データパックフォルダ名
        private const string DatapackFolderName = "asa_animator";
        // キーフレームフォルダ名
        private const string KeyframesFolderName = "keyframes";
        // tick -> 秒
        private const float TickToSec = 0.05f;

        public void GenerateDatapack(AnimationManager animationManager, GeneralSettingUI generalSetting, AnimationSettingUI animationSetting, List<Node> nodeList, List<Keyframe> keyframeList)
        {
            // ファイルパス決定
            var extensionList = new[] { new ExtensionFilter("folder", "") };

            var paths = StandaloneFileBrowser.OpenFolderPanel("Save File", "", false);
            // ファイルを選択しなかった場合，中断
            if (paths.Length < 1)
                return;
            var path = paths[0];

            // 設定取得
            this.generalSetting = generalSetting;

            // モデル名，アニメーション名取得
            modelName = generalSetting.ModelName;
            animationName = animationSetting.AnimationName;

            // データパックフォルダ作成
            path = Path.Combine(path, DatapackFolderName);
            Directory.CreateDirectory(path);
            var datapackPath = path;

            // ファンクションフォルダ作成
            path = Path.Combine(path, "functions");
            Directory.CreateDirectory(path);

            // モデル名フォルダ作成
            path = Path.Combine(path, generalSetting.ModelName.ToLower());
            Directory.CreateDirectory(path);

            // summon.mcfunction
            modelMcfunc.GenerateSummonFunction(path, generalSetting, nodeList, true, generalSetting.MultiEntities);
            // model.mcfunction   
            modelMcfunc.GenerateModelFunction(path, generalSetting, nodeList);
            // kill.mcfunction
            modelMcfunc.GenerateKillFunction(path, generalSetting);
            // get_data.mcfunction
            GenerateGetDataFunction(path, nodeList);
            // 複数対応用function
            if (generalSetting.MultiEntities)
            {
                // kill_target.mcfunction
                modelMcfunc.GenerateKillTargetFunction(path, generalSetting);
                // find_target.mcfunction
                GenerateFindTargetFunction(path);
                // reset_target.mcfunction
                GenerateResetTargetFunction(path);
            }

            // アニメーション名分割
            string[] anmName = animationSetting.AnimationName.Split('/');
            // アニメーション名フォルダ作成
            if (anmName.Length < 2)
                path = Path.Combine(path, anmName[0]);
            else
                foreach (string s in anmName)
                {
                    path = Path.Combine(path, s);
                }
            Directory.CreateDirectory(path);

            // 再生速度変換済みキーフレーム
            int index = 0;
            var spdKeyframeList = new List<Keyframe>();
            foreach (Keyframe k in keyframeList)
            {
                var newKey = new Keyframe(index, Mathf.FloorToInt(k.tick / animationSetting.AnimationSpeed), k.rootPos, k.rotations, k.isQuick);
                spdKeyframeList.Add(newKey);
            }

            // tickごとのRotate, Posを計算
            index = 0;
            var tickedKeyframeList = new List<List<Vector3[]>>();
            while (index < spdKeyframeList.Count - 1)
            {
                // tick
                float t = 0.0f;
                // アニメーション時間
                float animationTime = (spdKeyframeList[index + 1].tick - spdKeyframeList[index].tick) * TickToSec;

                // indexからindex+1までアニメーション再生
                while (t < animationTime)
                {
                    // tickキーフレーム
                    var tickedKeyframe = new List<Vector3[]>();

                    // 1tick毎の各ノードの角度を計算
                    var lerpTime = t / animationTime;
                    var rootX = Mathf.Lerp(spdKeyframeList[index].rootPos.x, spdKeyframeList[index + 1].rootPos.x, lerpTime);
                    var rootY = Mathf.Lerp(spdKeyframeList[index].rootPos.y, spdKeyframeList[index + 1].rootPos.y, lerpTime);
                    var rootZ = Mathf.Lerp(spdKeyframeList[index].rootPos.z, spdKeyframeList[index + 1].rootPos.z, lerpTime);
                    var rootPos = new Vector3(rootX, rootY, rootZ);
                    var rotations = new List<Vector3>();
                    for (int i = 0; i < spdKeyframeList[index].rotations.Count; i++)
                    {
                        var rotateX = Mathf.Lerp(spdKeyframeList[index].rotations[i].x, spdKeyframeList[index + 1].rotations[i].x, lerpTime);
                        var rotateY = Mathf.Lerp(spdKeyframeList[index].rotations[i].y, spdKeyframeList[index + 1].rotations[i].y, lerpTime);
                        var rotateZ = Mathf.Lerp(spdKeyframeList[index].rotations[i].z, spdKeyframeList[index + 1].rotations[i].z, lerpTime);
                        rotations.Add(new Vector3(rotateX, rotateY, rotateZ));
                    }

                    // ノードを動かす
                    var dummyKey = new Keyframe(0, 0, rootPos, rotations, false);
                    animationManager.SetNodeRotation(dummyKey);

                    // ノードの位置・角度を取得
                    foreach (Node n in nodeList)
                    {
                        var tickedNodeData = new Vector3[2];
                        // 位置（座標系変換）
                        tickedNodeData[0] = n.transform.position;
                        // tickedNodeData[0] = n.GetPosition();
                        tickedNodeData[0].x *= -1;
                        // 角度
                        tickedNodeData[1] = n.rotate + n.GetRotation();
                        tickedKeyframe.Add(tickedNodeData);
                    }

                    t += TickToSec;
                    // tick毎キーフレーム追加
                    tickedKeyframeList.Add(tickedKeyframe);
                }

                // 次のキーフレームへ
                index++;
            }

            // メインファンクション：main.mcfunction
            GenerateMainFunction(path, spdKeyframeList, nodeList, tickedKeyframeList);
            // 終了ファンクション：end.mcfunction
            GenerateEndFunction(path);

            // Keyframesフォルダ作成
            path = Path.Combine(path, KeyframesFolderName);
            Directory.CreateDirectory(path);

            // tickedキーフレーム用ファンクション：index.mcfunction
            GenerateKeyframeFunction(path, nodeList, tickedKeyframeList);

            Debug.Log("Animation Datapack Exported");

            // フォルダ表示
            System.Diagnostics.Process.Start(datapackPath);
        }

        // get_data.mcfunction
        private void GenerateGetDataFunction(string path, List<Node> nodeList)
        {
            // ファイルパス決定
            path = Path.Combine(path, "get_data.mcfunction");
            // .mcfunction書き込み用
            var writer = new StreamWriter(path, false);
            // Author
            writer.WriteLine(FuncAuthor);

            // データ初期化
            string func = "data modify storage asa_temp: Data set value []";
            writer.WriteLine(func);

            // 各ノードのデータを取得する
            foreach (Node n in nodeList)
            {
                string selector = "";
                if (generalSetting.MultiEntities)
                    selector = $"@e[type=armor_stand,tag={modelName}Parts,tag={n.nodeName},tag=AsaTarget]";
                else
                    selector = $"@e[type=armor_stand,tag={modelName}Parts,tag={n.nodeName}]";
                func = $"execute as {selector} run data modify storage asa_temp: Data append from entity @s";
                writer.WriteLine(func);
            }

            // 終了
            writer.Flush();
            writer.Close();

            Debug.Log("Generated get_data mcfunction");
        }

        // find_target.mcfunction
        private void GenerateFindTargetFunction(string path)
        {
            // ファイルパス決定
            path = Path.Combine(path, "find_target.mcfunction");
            // .mcfunction書き込み用
            var writer = new StreamWriter(path, false);
            // Author
            writer.WriteLine(FuncAuthor);

            string func = "";
            string selector = $"@e[type=armor_stand,tag={modelName}Parts]";

            // ID退避
            func = "scoreboard players operation #asa_temp_id AsamID = @s AsamID";
            writer.WriteLine(func);

            // IDが同じエンティティにタグを付与する
            func = $"execute as {selector} if score @s AsamID = #asa_temp_id AsamID run tag @s add AsaTarget";
            writer.WriteLine(func);

            // 終了
            writer.Flush();
            writer.Close();

            Debug.Log("Generated find_target mcfunction");
        }

        // reset_target.mcfunction
        private void GenerateResetTargetFunction(string path)
        {
            // ファイルパス決定
            path = Path.Combine(path, "reset_target.mcfunction");
            // .mcfunction書き込み用
            var writer = new StreamWriter(path, false);
            // Author
            writer.WriteLine(FuncAuthor);

            string func = "";
            string selector = $"@e[type=armor_stand,tag={modelName}Parts,tag=AsaTarget]";

            // タグ消去
            func = $"tag {selector} remove AsaTarget";
            writer.WriteLine(func);

            // 終了
            writer.Flush();
            writer.Close();

            Debug.Log("Generated reset_target mcfunction");
        }

        // main.mcfunction
        private void GenerateMainFunction(string path, List<Keyframe> keyframeList, List<Node> nodeList, List<List<Vector3[]>> tickedKeyframeList)
        {
            // ファイルパス決定
            var tempPath = path;
            path = Path.Combine(path, "main.mcfunction");
            // .mcfunction書き込み用
            var writer = new StreamWriter(path, false);

            // Author
            writer.WriteLine(FuncAuthor);

            // コメント
            writer.WriteLine("# Main Functions");

            string func = "";
            string execute = "";

            // Rootタイマー増加
            func = $"scoreboard players add @s AsaMatrix 1";
            writer.WriteLine(func);

            // 複数対応の場合，対象を特定
            if (generalSetting.MultiEntities)
            {
                func = $"function asa_animator:{modelName.ToLower()}/find_target";
                writer.WriteLine(func);
            }

            // Root移動
            for (int i = 0; i < keyframeList.Count - 1; i++)
            {
                // アニメーション時間(tick)
                var time = keyframeList[i + 1].tick - keyframeList[i].tick;
                // 移動距離
                var moveX = -(keyframeList[i + 1].rootPos.x - keyframeList[i].rootPos.x) / time;
                var moveY = (keyframeList[i + 1].rootPos.y - keyframeList[i].rootPos.y) / time;
                var moveZ = (keyframeList[i + 1].rootPos.z - keyframeList[i].rootPos.z) / time;
                // 書き込み
                execute = $"execute if entity @s[scores={{AsaMatrix={keyframeList[i].tick + 1}..{keyframeList[i + 1].tick}}}] run ";
                func = $"tp @s ^{moveX:F2} ^{moveY:F2} ^{moveZ:F2}";

                writer.WriteLine(execute + func);
            }

            // end実行
            execute = $"execute if entity @s[scores={{AsaMatrix={keyframeList[keyframeList.Count - 1].tick + 1}..}}] run ";
            func = $"function asa_animator:{modelName.ToLower()}/{animationName.ToLower()}/end";
            writer.WriteLine(execute + func);

            // 改行
            writer.WriteLine("");
            writer.WriteLine("# Keyframe Functions");

            // データ取得
            func = $"function asa_animator:{modelName.ToLower()}/get_data";
            writer.WriteLine(func);

            // tickedKeyframe実行
            for (int i = 1; i <= tickedKeyframeList.Count; i++)
            {
                if (i >= tickedKeyframeList.Count)
                    execute = $"execute if entity @s[scores={{AsaMatrix={i}..}}] run ";
                else
                    execute = $"execute if entity @s[scores={{AsaMatrix={i}}}] run ";
                func = $"function asa_animator:{modelName.ToLower()}/{animationName.ToLower()}/{KeyframesFolderName}/{i}";
                writer.WriteLine(execute + func);
            }

            // model実行
            func = $"function asa_animator:{modelName.ToLower()}/model";
            writer.WriteLine(func);

            // 複数対応の場合，対象を解放
            if (generalSetting.MultiEntities)
            {
                func = $"function asa_animator:{modelName.ToLower()}/reset_target";
                writer.WriteLine(func);
            }

            // 終了
            writer.Flush();
            writer.Close();

            Debug.Log("Generated main mcfunction");
        }

        // end.mcfunction
        private void GenerateEndFunction(string path)
        {
            // ファイルパス決定
            path = Path.Combine(path, "end.mcfunction");
            // .mcfunction書き込み用
            var writer = new StreamWriter(path, false);

            // Rootのタイマーリセット
            var func = $"scoreboard players set @s AsaMatrix 0";
            writer.WriteLine(func);

            // 終了
            writer.Flush();
            writer.Close();

            Debug.Log("Generated end mcfunction");
        }

        // keyframe/index.mcfunction
        private void GenerateKeyframeFunction(string path, List<Node> nodeList, List<List<Vector3[]>> tickedKeyframeList)
        {
            // ファイルパス
            string funcPath = "";
            // .mcfunction書き込み用
            StreamWriter writer;

            // 各ノードのArmorItems[3].tag.Rotateをkeyframeのrotationsに設定
            for (int i = 0; i < tickedKeyframeList.Count; i++)
            {
                // キーフレーム
                var tickedKeyframe = tickedKeyframeList[i];
                
                // パス決定
                funcPath = Path.Combine(path, $"{i + 1}.mcfunction");
                writer = new StreamWriter(funcPath, false);

                // RootPos取得
                string func = "function #asa_matrix:get_parent_pos";
                writer.WriteLine(func);
                // RootRotation・回転行列取得
                func = "data modify storage asa_temp: Temp.Rotation set from entity @s Rotation";
                writer.WriteLine(func);
                func = "function #asa_matrix:matrix_world";
                writer.WriteLine(func);

                // 各ノードで実行
                int j = 0;
                foreach (Node n in nodeList)
                {
                    // ノードRotation更新
                    func = $"data modify storage asa_temp: Data[{j}].Rotation set from storage asa_temp: Temp.Rotation";
                    writer.WriteLine(func);
                    // ノードPose.Head更新
                    func = $"data modify storage asa_temp: Data[{j}].Pose.Head set value [{tickedKeyframe[j][1].x}f,{tickedKeyframe[j][1].y}f,{tickedKeyframe[j][1].z}f]";
                    writer.WriteLine(func);
                    // スコアにノードのPosを代入
                    func = $"scoreboard players set #asa_child_pos_x AsaMatrix {Mathf.FloorToInt(tickedKeyframe[j][0].x * 1000)}";
                    writer.WriteLine(func);
                    func = $"scoreboard players set #asa_child_pos_y AsaMatrix {Mathf.FloorToInt(tickedKeyframe[j][0].y * 1000)}";
                    writer.WriteLine(func);
                    func = $"scoreboard players set #asa_child_pos_z AsaMatrix {Mathf.FloorToInt(tickedKeyframe[j][0].z * 1000)}";
                    writer.WriteLine(func);
                    // RotationでPosを回転
                    func = "function #asa_matrix:rotate_world";
                    writer.WriteLine(func);
                    func = "function #asa_matrix:get_child_pos";
                    writer.WriteLine(func);
                    // ノードPos更新
                    func = $"execute store result storage asa_temp: Data[{j}].Pos[0] double 0.001 run scoreboard players get #asa_child_pos_x AsaMatrix";
                    writer.WriteLine(func);
                    func = $"execute store result storage asa_temp: Data[{j}].Pos[1] double 0.001 run scoreboard players get #asa_child_pos_y AsaMatrix";
                    writer.WriteLine(func);
                    func = $"execute store result storage asa_temp: Data[{j}].Pos[2] double 0.001 run scoreboard players get #asa_child_pos_z AsaMatrix";
                    writer.WriteLine(func);
                    
                    j++;
                }

                // 終了
                writer.Flush();
                writer.Close();
            }

            Debug.Log("Generated keyframe mcfunction");
        }
    }
}